在google中输入“前端性能优化”，可以找到约  11,300,000 条结果，目前性能已经被列入google的网站的排名规则中。
	
	根据著名的“2-5-8原则”，用户访问一个页面：
	· 当用户能够在2秒以内得到响应时，会感觉系统的响应很快；
	· 当用户在2-5秒之间得到响应时，会感觉系统的响应速度还可以；
	· 当用户在5-8秒以内得到响应时，会感觉系统的响应速度很慢，但是还可以接受；
	· 当用户在超过8秒后仍然无法得到响应时，会感觉系统糟透了，或者认为系统已经失去响应，而选择离开这个Web站点，或者发起第二次请求。

<em> 据数据统计 --- </em>

	· Pinterest重建了他们的页面以实现性能，使感知等待时间减少了40％，从而将搜索引擎流量和注册量提高了15％。
	
	· BBC发现，他们在网站加载的每一秒钟内就会损失10％的用户。
	
由此可见性能优化的重要性，看到这些数据，觉得背后一凉，那就赶紧把性能优化提上日程，开始我们的实战吧！

 **本篇将从以下三个方向来进行探讨:**
 	· 提升编译性能
 	· 项目中冗余模块去重
 	· 首屏优化

### 提升编译性能
对于一个大型项目，编译中需要耗时5分钟真的是很鸡肋的事情，无尽的等待，消耗的不只是时间，还有我们搬砖的热情！
2018年2月25日，webpack发布了4.0版本，该版本简化了配置选项等，带来巨大的性能提升，官方曾表示能使编译速度提升 60% - 80%，因此我们决定升级webpack4，从而缩短编译时间，结束漫长的等待。

首先，我们先来了解一下，webpack4 有哪些新特性：

**1、零配置启动项目，简化配置依赖！**
可能是受到parcel的启发，不再强制需要webpack.config.js作为打包配置文件。

**2、mode属性，设置打包环境高效！**
支持两种配置：development || production
``` script
"scripts": {
  "dev": "webpack --mode development",
  "build": "webpack --mode production"
}
```
	将 mode 设置成 development，你将获得最好的开发阶段体验（浏览器调试工具；注释，错误日志和提示；优化的增量构建机制等）
	
	将mode设置成了 production, webpack将会专注项目的部署（优化代码；压缩bundle体积；删除开发阶段代码；Tree-shaking等）

**3、环境支持，代码整洁健壮！**
webpack4不再支持Node4，使用时，确保使用 Node.js的版本 >= 8.9.4。使用了很多JS新的语法，更好的利用ES6语法的优势。

**4、插件删除和优化，减小体积**
删除了CommonsChunkPlugin插件，它使用内置API optimization.splitChunks 和 optimization.runtimeChunk

**5、支持多个头等模块类型，支持 WebAssembly(wasm)**
WebAssembly(wasm)会带来运行时性能的大幅度提升，甚至通过loaders来直接import Rust、C++、C 文件，然后像使用 JavaScript 模块那样使用它们。

	· javascript/auto: 在webpack3里，默认开启对所有模块系统的支持，包括CommonJS、AMD、ESM。
	· javascript/esm: 只支持ESM这种静态模块。
	· javascript/dynamic: 只支持CommonJS和AMD这种动态模块。
	· json: 只支持JSON数据，可以通过require和import来使用。
	· webassembly/experimental: 只支持wasm模块，目前处于试验阶段。

**6、重构的插件系统**
插件系统是 Webpack 的核心组件，这意味着插件钩子的调用频率非常高，许多钩子函数都是调用热点。

	· 所有的hook由 hooks 对象统一管理，它将所有的hook作为可扩展的类属性。
	· 当添加插件时，必须提供一个插件名称。
	· 开发插件时，可以选择sync/callback/promise作为插件类型。
	· 可以通过this.hooks = { myHook: new SyncHook(...) } 来注册hook了。
	
了解了webpack4的新特性，下面我们来聊一聊如何进行合理配置优化性能
	
	TODO 重点 待补充。。。 。。。
	· 通过CDN的方式引入，减少vendor.js体积
	· 开启gzip压缩，生成压缩文件
	· 代码分离

// 多线程编译babel
    new HappyPack
    
MiniCssExtractPlugin
VueLoaderPlugin



### 项目中冗余模块去重
对于大型项目来说，多次迭代和多人维护难免会有模块的重复引入，造成打包后文件增大，这个时候我们怎么能及时发现并优化她呢？

![图片1](./img/1.jpeg)

举个项目中曾经遇到的情况，轮播图很常见的一个功能，由于不同时期开发，导致项目中引入了两个带有swipter的包：vue-awesome-swiper 和 Mint UI

![图片2](./img/2.jpeg)

哇！ 好神奇，这个是什么高科技?
**webpack-bundle-analyzer** 
这是webpack的一个特殊插件，可以查看项目打包后各个静态资源大小占比。

首先，安装
```javascript
# NPM 
npm install --save-dev webpack-bundle-analyzer
# Yarn 
yarn add -D webpack-bundle-analyzer
```

其次，配置（webpack.prod.conf.js）
更多设置请参照 [https://www.npmjs.com/package/webpack-bundle-analyzer](webpack-bundle-analyzer)
```javascript
const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;

module.exports = {
  plugins: [
    new BundleAnalyzerPlugin()
  ]
}
```

最后，运行
```javascript
npm run build-report
```
这时候你的浏览器就会出现这个花花绿绿的页面了，这个时候文件中引入了什么包一目了然。接下来就是，优化它！

![图片3](./img/3.jpeg)

上图显示仅仅去掉了一个包，就减少了0.27MB！



### 首屏优化

	•	首屏渲染
	•	按需加载（重点）
	•	懒加载
	
文章开头谈到了著名的“2-5-8原则”，为了留住用户，开一个好头尤为重要。
首先我们要做的是尽量优化首屏渲染体验
#### 浏览器缓存


#### 图片懒加载
```javascript
import VueLazyload from 'vue-lazyload'

Vue.use(VueLazyload)
Vue.use(VueLazyload, 
	{ 	preLoad: 1.8,
	  	error: require('@/assets/lazy/error.png'),
		loading: require('@/assets/lazy/loading.png'),
		attempt: 1,
		listenEvents: ['scroll']
	}
)
// 在使用图片的地方加上v-lazy即可
<img v-lazy="img.src" >
```
？ 注意：商品图和头像适当剪裁，这一步需要运维协助。
![图片4](./img/4.jpeg)

#### 骨架屏



















好了,就写到这了，希望看过后对你能有帮助。


